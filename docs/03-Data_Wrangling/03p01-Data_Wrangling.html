<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>CEMA 0907: Statistics in the Real World</title>
    <meta charset="utf-8" />
    <meta name="author" content="Anthony Scotina" />
    <link rel="stylesheet" href="my-theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# CEMA 0907: Statistics in the Real World
## The ‘pipe’ Operator, and filter()
### Anthony Scotina

---







# What have we done so far?

**Data Exploration**


```r
library(nycflights13)
flights
```

```
# A tibble: 336,776 x 19
    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
 1  2013     1     1      517            515         2      830            819
 2  2013     1     1      533            529         4      850            830
 3  2013     1     1      542            540         2      923            850
 4  2013     1     1      544            545        -1     1004           1022
 5  2013     1     1      554            600        -6      812            837
 6  2013     1     1      554            558        -4      740            728
 7  2013     1     1      555            600        -5      913            854
 8  2013     1     1      557            600        -3      709            723
 9  2013     1     1      557            600        -3      838            846
10  2013     1     1      558            600        -2      753            745
# … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
#   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
#   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

---

# What have we done so far?

**Data Visualization**


```r
flights %&gt;%
  filter(carrier == "F9") %&gt;%
  ggplot(mapping = aes(x = dep_delay, y = arr_delay)) + 
  geom_point(alpha = 0.2) + 
  labs(x = "Departure Delay (in minutes)", 
       y = "Arrival Delay (in minutes)") + 
  theme_minimal()
```

---

# What have we done so far?

**Data Visualization**

&lt;img src="03p01-Data_Wrangling_files/figure-html/unnamed-chunk-4-1.png" width="60%" /&gt;

---

# What will we do now?

**Data Wrangling**


```r
*flights %&gt;%
* filter(carrier == "F9") %&gt;%
  ggplot(mapping = aes(x = dep_delay, y = arr_delay)) + 
  geom_point(alpha = 0.2) + 
  labs(x = "Departure Delay (in minutes)", 
       y = "Arrival Delay (in minutes)") + 
  theme_minimal()
```

---

# Data Wrangling in R? 

**dplyr**

.center[
&lt;img src="dplyr_hex.png" width="40%" /&gt;
]

---

# Needed Packages 


```r
library(tidyverse) # includes ggplot2 and dplyr
library(gapminder)
library(nycflights13)
```

---

class: middle, center

# The Pipe Operator `%&gt;%`

---

# The Pipe Operator `%&gt;%`

Say you want to perform a set of operations on the `flights` data frame:

1. Take `flights`, then...

--

2. `filter` for *only* Jet Blue flights (carrier code "B6"), then...

--

3. `group_by` departure airport (`origin`), then...

--

4. `summarize` the *average flight distance* (`distance`) by departure airport. 

---

# The Pipe Operator `%&gt;%`

Say you want to perform a set of operations on the `flights` data frame:

**Use the pipe operator!** (`%&gt;%`)


```r
flights %&gt;%
  filter(carrier == "B6") %&gt;%
  group_by(origin) %&gt;%
  summarize(mean(distance))
```

```
# A tibble: 3 x 2
  origin `mean(distance)`
  &lt;chr&gt;             &lt;dbl&gt;
1 EWR                815.
2 JFK               1114.
3 LGA               1030.
```

---

# The Pipe Operator `%&gt;%`

You would read this sequence as:

1. Take `flights`, then...
2. Use this output as the input to the next function, `filter`, then...
3. Use this output as the input to the next function, `group_by`, then...
4. Use this output as the input to the next function, `summarize`.

--

**The starting value will always be the data frame!**

- The sequence of functions that follow will consist of some combination of **verb-named functions** that we will discuss throughout class today. 
- The result will the transformed/modified data frame that you want. For example, 
    - A data frame consisting of only the subset of rows in flights corresponding to Jet Blue flights.
    - A data frame consisting of average flight distance separated by origin. 
    
---

# The Pipe Operator `%&gt;%`

In `dplyr`, the pipe operator (`%&gt;%`) plays a very similar role to the `+` operator when adding layers in `ggplot2`.

You can even save "piped" operations as a new data frame. In fact, we have already done it!

**Example** (from yesterday): Weather at the JFK airport in New York, between November 1 and November 18:


```r
jfk.nov = weather %&gt;%
  filter(origin == "JFK" &amp; month == 11 &amp; day &lt;= 18)
```

---

# The Pipe Operator `%&gt;%`

**Keyboard shortcut!!!**

[control]+[shift]+[m]

---

class: middle, center

# Verb-Named Functions

---

# Verb-Named Functions

We will cover the following functions from the `dplyr` package. These will take a data frame and...

1. `filter()` its existing rows to only pick out a subset of them. 

--

2. `summarize()` one of its columns/variables with a summary statistic (e.g., mean, median, IQR).

--

3. `group_by()` its rows. In other words assign different rows to be part of the same group and report summary
statistics for each group separately.

--

4. `mutate()` its existing columns/variables to create new ones. For example, convert flight distance from *miles* to *kilometers*. 

--

5. `arrange()` its rows. For example, sort flights based on descending delay time.

---

# `select()` columns

.center[
&lt;img src="dplyr_select.png" width="359" /&gt;
]

`select()` allows you to return a *subset* of **columns** of a data frame. 

- This might not seem like much, but data frames with *many* columns (i.e., hundreds of variables) are not uncommon. 

---

# `select()` columns

The `gapminder` data frame in the `gapminder` package contains data on life expectancy, GDP per capita, and population by country, spanning 1952-2007 (in increments of 5 years). 


```r
View(gapminder)
```

--

Suppose we want a data frame with *only* the `country`, `year`, and `lifeExp` variables (columns). 


```r
gapminder_new = gapminder %&gt;%
  select(country, year, lifeExp)
View(gapminder_new)
```

---

# `filter()` rows

.center[
&lt;img src="dplyr_filter.png" width="70%" /&gt;
]

- Specify criteria about the values of a variables in your dataset.

- `filter()` out only those rows that match that criteria.

---

# `filter()`

Let's focus only on flights from New York City to Boston, Massachusetts (`dest` code is "BOS").

Run the following code, and use `View` to ensure that the only `dest` entries are "BOS":

```r
flights.bos = flights %&gt;%
  filter(dest == "BOS")
View(flights.bos)
```

--

We performed the following steps:

1. Take the `flights` data frame, and then...
2. `filter` the data frame so that only rows where `dest` equals "BOS" are included. 

**Note**: We *test for equality* with `==`, rather than `=`. The single `=` is used for *assignment*. 

---

# Other Criteria in `filter()`

You can use other criteria in `filter()` besides *equality* (`==`):
- `&lt;`: "less than"
- `&gt;`: "greater than"
- `&lt;=`: "less than or equal to"
- `&gt;=`: "greater than or equal to"
- `!=`: "not equal to"

--

You can also combine *multiple criteria*:
- `&amp;`: "and" 
    - **Example**: `day &lt;= 15 &amp; distance &gt;= 1000`

- `|`: "or"
    - **Example**: `month != 3 | distance &gt;= 1000`

---

# `select()` and `filter()` together

Similar to when using *only* `select()`, we might want to perform other operations on the data in conjunction with `filter()`. 

- We can conveniently construct a single *pipeline* with all of the operations!


```r
gapminder_new = gapminder %&gt;%
  select(country, year, lifeExp) %&gt;%
  filter(country == "United States")
View(gapminder_new)
```

--

You can even add a plot at the end of a pipeline!


```r
gapminder %&gt;%
  select(country, year, lifeExp) %&gt;%
  filter(country == "United States") %&gt;%
  ggplot(aes(x = year, y = lifeExp)) + 
  geom_line() + 
  labs(x = "Year", y = "Life Expectancy", title = "US Life Expectancy")
```

---

# Non-pipeline equivalent

Here is the equivalent code that does not use the `%&gt;%` operator:


```r
gapminder_new = select(gapminder, country, year, lifeExp)
gapminder_new = filter(gapminder_new, country == "United States")
ggplot(gapminder_new, aes(x = year, y = lifeExp)) + 
  geom_line() + 
  labs(x = "Year", y = "Life Expectancy", title = "US Life Expectancy")
```

---

# Filtering on multiple criteria

We are not limited to a single criterion when using `filter()`. 

- We can string together multiple criteria with `&amp;` ("and"). 


```r
gapminder_new = gapminder %&gt;%
  filter(country %in% c("United States", "Canada") &amp;
           year &gt;= 1980)
View(gapminder_new)
```

The result of this pipeline is a data frame that includes data on *only* the countries **United States** *or* **Canada**, in **1980 or later**.

--

**Note**: We use the `%in%` to check for rows with `country` equal to *either* `"United States"` **or** `"Canada"`.

---

# Practice

Using the `flights` dataset in the `nycflights13` package...

1. Filter `flights` for all rows that:

    - Departed from JFK (`origin == "JFK"`) airport **and**

    - Were heading to Burlington, Vermont (`dest == "BTV"`) **or** Seattle, Washington (`dest == "SEA"`) **and**

    - Departed in the months of October, November, or December.

2. Select the destination, departure delay, arrival delay, and flight carrier variables from the data. 

3. If you're feeling up to it, use the resulting data to make a **scatterplot** of arrival delay versus departure delay!

---

# Practice

**Solution**


```r
flights_new = flights %&gt;%
  filter(origin == "JFK" &amp;
           dest %in% c("BTV", "SEA") &amp; 
           month %in% c(10, 11, 12)) %&gt;%
  select(dest, dep_delay, arr_delay, carrier)

flights_new %&gt;%
  ggplot(aes(x = dep_delay, y = arr_delay)) + 
  geom_point(alpha = 0.4) +
  theme_bw() + 
  labs(x = "Departure Delay (in mins)", y = "Arrival Delay (in mins)")
```

(Note the careful use of parentheses around `dest == "BTV" | dest == "SEA"`.)

You can use the `%in% c(...)` to string together multiple "or" statements.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"countIncrementalSlides": false,
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
